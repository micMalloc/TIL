# Graph

#### Graph 정의

~~~
단순히 정점(Vertex, Node)과 해당 정점을 연결하는 간선(Edge)을 하나로 모아 놓은 자료구조
  > 현실세계의 사물이나 객체, 추상적인 개념 간의 연결 관계를 표현
    ex) 지도, 지하철 노선도, 전기회로, 도로, 선수 과목, 비행기 경로 등
  > 그래프는 여러 개의 고립된 부분 그래프로 구성될 수 있다. 즉, 반드시 모두 연결되어있지 않더	라도 그래프라 할 수 있다.
~~~



-----

#### 그래프 관련 용어

~~~
* 정점(Vertex): 그래프 상에서의 사물, 객체, 지점 혹은 위치의 개념
* 간선(Edge)  : 그래프 상의 위치 혹은 객체들간의 관계, 즉 정점들을 연결하는 선
* 인접 정점(Adjacnet Vertex) : 간선에 의해 직접 연결된 정점
* 정점의 차수(Degree) : 양방향 혹은 무방향 그래프에서 하나의 정점에 인접한 정점의 수
* 진입 차수(In-Degree) : 방향 그래프에서 외부에서 오는 간선의 수 (=내차수)
* 진출 차수(Out-Degree) : 방향 그래프에서 외부로 나가는 간선의 수 (=외차수)
* 경로 (Path) : 하나의 정점으로부터 다른 정점으로 가는데 쓰여진 간선들의 집합
	- 경로의 길이는 쓰여진 간선들의 개수
* 단순 경로 : 경로 중에서 반복되는 정점이 없는 경우
* 사이클(Cycle) : 단순 경로의 시작 정점과 종료 정점이 동일한 경우
~~~



----

#### 그래프의 특징

~~~
* 그래프는 하나의 네트워크 모델이다.
* 루트 노드라는 개념이 따로 존재하지 않는다.
* 부모 - 자식 관계라는 개념이 없다.
~~~



----

#### 그래프의 종류

> 양방향 혹은 무방향 그래프 (***Undirected Graph*** or ***Two-way Directed Graph***)
>
> ~~~
> * 양방향 그래프의 간선은 해당 간선을 통해 양방향으로 갈 수 있다.
> * 정점 A와 정점 B를 연결하는 간선은 (A, B)와 같이 정점의 쌍으로 표현된다.
> 	- (A, B)와 (B, A)는 동일하다.
> ~~~

>방향 그래프 (***Directed Graph***)
>
>~~~
>* 간선의 방향성이 존재하는 그래프
>* 정점 A에서 정점 B로 가는 간선은 <A, B>로 표시된다.
>	- <A, B>와 <B, A>는 서로 다른 간선이다.
>~~~

> 가중치 그래프 (***Weighted Graph***)
>
> ~~~
> * 두 정점을 연결하는 간선에 비용이나 가중치가 할당된 그래프
> * "네트워트"라고도 한다.
> 	ex) 도시 - 도시로 가는 비용, 도로의 길이, 통신망의 사용료 등
> ~~~

> 연결 그래프 (***Connected Graph***)
>
> ~~~
> * 하나의 그래프에 있는 모든 정점들간에 항상 경로가 존재하는 경우
> 	ex) 트리 (하나의 그래프로서 사이클을 가지지 않는 연결 그래프)
> ~~~

>비연결 그래프 (***Disconnected Graph***)
>
>~~~
>* 하나의 그래프에서 특정 정점들 사이에 경로가 존재하지 않는 경우
>	- 하나의 정점에서 그 외 다른 정점과 하나라도 경로가 없다면 비연결 그래프이다.
>~~~

> 완전 연결 그래프 (***Complete*** *Connected* ***Graph***)
>
> ~~~
> * 하나의 그래프에 속해 있는 모든 정점들이 서로서로 연결되어 있는 그래프
> 	- 즉, 모든 정점들이 서로서로 인접하다는 의미를 지닌다.
> ~~~

> 순환 그래프 (***Cyclic Graph***)
>
> ~~~
> * 하나의 그래프 속의 단순 경로 중 시작 정점과 종료 정점이 동일한 사이클이 존재하는 그래프
> 	- 즉, 사이클이 존재하는 그래프
> ~~~

> 비순환 그래프 (***Acyclic Graph***)
>
> ~~~
> * 하나의 그래프 속의 단순 경로 중 사이클이 존재하지 않는 그래프
> 	- 즉, 사이클이 존재하지 않는 그래프
> ~~~



---

#### 그래프의 구현 (*Graph Representation*)

~~~
그래프 속 정점들 간의 인접을 통해 그래프를 구현한다.
그래프를 구현하는데 있어 2가지 방식이 존재한다.
1. 인접 행렬 (Adjacent Matrix)
2. 인접 리스트 (Adjacent List)
~~~

> ***인접 행렬 (Adjacent Matrix)***
>
> ~~~c
> NxN 2차원 배열을 통해 구현되며, 각각의 원소들은 true 혹은 false와 같은 Boolean 값 혹은 가중치 값을 가지게 된다. (1 혹은 0인 정수 역시 가질 수 있다.)
>  - Matrix[1][2] = true 인 경우 1 --> 2 로의 간선이 존재한다는 의미이다. 
>    즉, 1과 2는 인접하다는 의미를 갖게 된다.
>    
> /* 두 정점 u & v */
> if (간선 (u, v)가 존재한다면) {
>     adjacent_matrix[u][v] = true;
> }
> else {
>     adjacent_matrix[u][v] = false;
> }
> ~~~

> ***인접 리스트 (Adjacent List)***
>
> ~~~c
> 모든 정점을 인접 리스트에 저장한다. 즉, 각각의 정점에 인접한 정점들을 리스트에 저장한다.
> 배열과 배열의 각 인덱스마다 존재하는 또 다른 리스트(배열, 동적 가변 크기 배열, 연결리스트 등)를 사용하여 인접리스트를 구현한다.
> 
> 1 -> 2 -> 3
> 2 -> 1 -> 4
> 3 -> 2
> 4 -> 5
> 5 -> 1
>     
> /* vector를 사용한 인접 리스트 구현 */
> if (간선 (u, v)가 존재한다면) {
>     adjacent_list[u].push_back(v);
> }
> ~~~

>**인접 리스트와 인접 행렬 비교**
>
>>***[인접 리스트 (Adjacent List)](https://github.com/micMalloc/DataStructure/blob/master/Graphs/Representation/AdjacencyMatrix.cpp)***
>>
>>* 그래프 내에 간선의 정보가 적은 ***희소 그래프(Sparse Graph)***의 경우
>>
>>* 장점
>>
>>  * 어떤 노드에 인접한 노드들을 쉽게 찾을 수 있다.
>>  * 그래프에 존재하는 모든 간선의 수는 O(N + E) 안에 찾을 수 있다.
>>
>>* 단점
>>
>>  * 간선의 존재 여부와 정점의 차수를 구할 시 하나의 정점의 차수만큼의 시간이 필요
>>
>>    Ex) 1번 노드의 차수가 3개인 경우 2와 인접한지를 알기 위해선 1번의 리스트를 모두 확인하여야 한다
>>
>>***[인접 행렬 (Adjacent Matrix)](https://github.com/micMalloc/DataStructure/blob/master/Graphs/Representation/AdjacencyList.cpp)***
>>
>>* 그래프에 간선이 많이 존재하는 밀집 그래프(Dense Graph)의 경우
>>
>>* 장점
>>
>>  * 두 정점을 연결하는 간선의 존재여부를 O(1)로 찾을 수 있다.
>>  * 한 정점의 차수는 O(N) 안에 알 수 있다. 
>>
>>* 단점
>>
>>  * 어떤 노드에 인접한 노드들을 찾기 위해서는 모든 노드를 순회해야 한다.
>>
>>    즉, 연결되어 있지 않더라도 확인하여야한다는 의미
>>
>>  * 그래프에 존재하는 모든 간선의 수는 O(N^2) 안에 찾을 수 있다.
>>
>>    즉, 인접 행렬 전체를 탐색해야한다.



-----

#### 그래프의 탐색

>그래프를 탐색하는 방법 두 가지
>
>1. ***[깊이 우선 탐색 (Depth-First Search)](https://github.com/micMalloc/DataStructure/blob/master/Graphs/Traversal/DepthFirstTraversal.cpp)***
>
>   ~~~
>   임의의 한 정점에서 시작하여 다음 분기 (Branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법
>   	* 즉, 넓게 탐색하기 전에 깊게 탐색하는 것이다.
>   	* 모든 노드를 방문 하고자 하는 경우에 이 방법을 선택한다.
>   ~~~
>
>2. ***[너비 우선 탐색 (Breadth-First Search)](https://github.com/micMalloc/DataStructure/blob/master/Graphs/Traversal/BreadthFirstTraversal.cpp)***
>
>   ~~~
>   임의의 한 정점에서 시작하여 인접한 노드를 먼저 탐색하는 방법
>   	* 깊게 탐색하기 전에 넓께 탐색하는 방법
>   	* 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 선택한다.
>   		단, 모든 간선의 비용이 동일한 경우 최단 경로를 보장한다.
>   ~~~