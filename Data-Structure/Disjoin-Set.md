# Disjoint-Set

**_서로소의 집합_**,  **_Union - Find Tree_**

서로소의 집합이란, 교집합이 공집합인 집합을 의미한다.

조금 더 정확한 정의를 내려보자면

```
Disjoint-Set은 `상호 배타적` 부분 집합들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조이다.
```

<br>

여기서 중요한 부분은 **_'독립적이다 '_**  와 **_'상호 배타적이다 '_** 의 차이를 이해하는 것이 중요하다.

우선, **_'독립적이다 '_**  라는 의미는

`A ∩ B = 0, A ∪ B = U `  이렇게 집합으로 표현할 수 있다.

이는 A와 B 사이에는 어떠한 관계도 존재하지 않다는 것을 의미한다.

<br>

다음으로, **_'상호 배타적이다 '_**  라는 의미는

`A ∩ B = 0, (A B) ⊂ C   ` 이렇게 집합으로 표현할 수 있다.

A와 B는 공집합이지만, 둘은 하나의 새로운 집단 C에 소속되어 있다는 의미를 가진다.

<br>

즉, 결론을 짓자면 

```
상호 배타적 관계의 사건 A와 B가 존재한다면 A와 B는 절대 동시에 일어날 수 없다.
하지만, 독립적 관계의 사건 A와 B는 동시에 발생할 수 있다.

이는 다시말해, 두 사건이 상호 배타적이라는 것은 두 사건 중 한 사건이 일어날 확률 [ P(A) or P(B) ]이 두 사건이 각각 일어날 단순 확률의 합 [ P(A) + P(B) ]과 같다를 의미한다.
```

<br>

# Implementation (C++)

Disjoint-Set을 구현하는데 있어 가장 중요한 세가지 함수들이 존재한다.

또한, Disjoint-Set의 또 다른 이름인 Union-Find Tree에서 알 수 있듯이 이 자료구조는 **_트리_**  구조를 취한다.

<br>

**_Disjoint-Set_** 세가지 주요 함수

* **_initialize function_** 

  * N 개의 원소가 각각의 집합에 포함되어 있도록 초기화 한다.

  * **_Code_**

    ```c++
    for (int i = 1; i <= N; ++ i) {
        parent[i] = i;
    }
    ```

* **_find function_**

  * 어떤 원소 a가 주어질 때, 이 원소가 속한 집합을 반환한다. [대표 원소 반환]

  * **_Code_**

    ```c++
    int find_set (int a) {
        /* 자신이 대표원소라면 자기 자신 반환하고 종료 */
        if (a == parent[a]) return a;
        /* 트리의 높이를 줄이기 위한 압축 기능 */
        return (parent[a] = find(parent[a]));
    }
    ```

    

* **_union function_**

  * 두 개의 집합을 하나의 집합으로 합친다.

  * **_Code_**

    ```c++
    void union_set (int a, int b) {
        /* 두 개의 원소의 속한 집합 찾기 */
        a = find(a);
        b = find(b);
        /* 같다면 같은 집합이기에 바로 종료시킨다. */
        if (a == b) return;
        /* 다르다면 두 개의 집합을 합친다. */
        parent[a] = b;
    }
    ```

    
